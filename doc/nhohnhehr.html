<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/2002/REC-xhtml1-20020801/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<title>The Nhohnhehr Programming Language</title>
  <!-- begin html doc dynamic markup -->
  <script type="text/javascript" src="/contrib/jquery-1.6.4.min.js"></script>
  <script type="text/javascript" src="/scripts/documentation.js"></script>
  <!-- end html doc dynamic markup -->
</head>
<body>

<h1>The Nhohnhehr Programming Language</h1>

<p><dfn>Nhohnhehr</dfn> is a remotely fungeoid esoteric programming language
designed by Chris Pressey between December 4 and December 8, 2010.</p>

<h2>Overview</h2>

<p>A Nhohnhehr program consists of a single object called a <i>room</i>, which is a 2-dimensional, square grid
of cells of finite, and usually small, extent.  To emphasize its bounds, the single room in a Nhohnhehr program text
must be delimited with an ASCII box, in the manner of the following:
</p>
<pre>+----+
|    |
|    |
|    |
|    |
+----+
</pre>
<p>Arbitrary text, including comments, may occur outside this bounding box; it will not be considered part of the Nhohnhehr program.
</p><p>Once defined, the contents of a room are immutable.  Although only a single room may appear in a program text, new rooms
may be created dynamically at runtime and adjoined to the edges of existing rooms (see below for details on how this works.)
</p>

<h2>Execution of Instructions</h2>

<p>In a running Nhohnhehr program there is an instruction pointer.  At any given time it has a definite position inside one of the
rooms of the program, and is traveling in one of the four cardinal directions.  It is also associated with a five-state variable called the
<i>edge mode</i>.  As the instruction pointer passes over non-blank cells, it executes them, heeding the following meanings:</p>

<pre> / causes the pointer to travel north if it was traveling east, south if travelling west.
 \ causes the pointer to travel north if it was traveling west, south if travelling east.
 = sets wrap edge mode.
 &amp; sets copy-room-verbatim edge mode.
 } sets copy-room-rotate-cw-90 edge mode.
 { sets copy-room-rotate-ccw-90 edge mode.
 ! sets copy-room-rotate-180 edge mode.
 # causes the instruction pointer to skip over the next cell (like # in Befunge-93.)
 ? inputs a bit.  If it is 0, rotate direction of travel 90 degrees counterclockwise;
   if it is 1, rotate direction of travel 90 degress clockwise; if no more input is
   available, the direction of travel does not change.
 0 outputs a 0 bit.
 1 outputs a 1 bit.
 @ halts the program.
 $ only indicates where initial instruction pointer is located; otherwise it has no effect.
   The initial direction of travel is east.
 blank cells are NOPs.
</pre>

<h2>Edge Crossing</h2>

<p>If the instruction pointer reaches an edge of the room and tries to cross it, what happens depends on the current edge mode:
</p>
<ul><li> In wrap edge mode (this is the initial edge mode), the pointer wraps to the corresponding other edge of the room, as if the room were mapped onto a torus.
</li><li> In all other modes, if there already exists a room adjoining the current room on that edge, the instruction pointer leaves the current room and enters the adjoining room in the corresponding position.  However, if no such adjoining room exists yet, one will be created by making a copy of the current room, transforming it somehow, and adjoining it.  The instruction pointer then enters the new room, just as if it had already existed.  The details of the transformation depend on the edge mode:
<ul><li> In copy-room-verbatim edge mode, no translation is done.
</li><li> In copy-room-rotate-cw-90 edge mode, the copy of the current room is rotated clockwise 90 degrees before being adjoined.
</li><li> In copy-room-rotate-ccw-90 edge mode, the copy of the current room is rotated counterclockwise 90 degrees before being adjoined.
</li><li> In copy-room-rotate-180 edge mode, the copy of the current room is rotated 180 degrees before being adjoined.
</li></ul>
</li></ul>

<h2>Examples</h2>

<p>The following example reads in a sequence of bits and creates a series of rooms, where 1 bits correspond to unrotated rooms and 0 bits correspond to rooms rotated 90 degrees clockwise (though not precisely one-to-one).
</p>
<pre>+------+
|    /}|
|&amp;#/$?@|
|  / \&amp;|
|      |
| {    |
|\\    |
+------+
</pre>
<p>After reading a 0 bit and leaving the right edge, the room is copied, rotated 90 degrees clockwise, and adjoined, so that the rooms of the program are:
</p>
<pre>+------+------+
|    /}|\   &amp; |
|&amp;#/$?@|\{  # |
|  / \&amp;|   // |
|      |    $ |
| {    |   \?/|
|\\    |   &amp;@}|
+------+------+
</pre>
<p>After leaving the right edge again, the current room is copied, this time rotated 90 degrees counterclockwise, and adjoined, and we get:
</p>

<pre>+------+------+------+
|    /}|\   &amp; |    /}|
|&amp;#/$?@|\{  # |&amp;#/$?@|
|  / \&amp;|   // |  / \&amp;|
|      |    $ |      |
| {    |   \?/| {    |
|\\    |   &amp;@}|\\    |
+------+------+------+
</pre>
<p>Say we were to now read in a 1 bit; we would thus have:
</p>
<pre>+------+------+------+------+
|    /}|\   &amp; |    /}|    /}|
|&amp;#/$?@|\{  # |&amp;#/$?@|&amp;#/$?@|
|  / \&amp;|   // |  / \&amp;|  / \&amp;|
|      |    $ |      |      |
| {    |   \?/| {    | {    |
|\\    |   &amp;@}|\\    |\\    |
+------+------+------+------+

</pre>
<p>It should be fairly clear at this point that this program will read all input bits, creating rooms thusly, terminating when there are no more input bits.
</p><p>The following program is a variation of the above which, when it encounters the end of input, writes out the bits in the reverse order they were read in, with the following changes:
</p>
<ul><li> for every "1" in the input, a "1" comes out
</li><li> for every "0" in the input, "10" comes out
</li><li> there's an extra "1" at the end of the output
</li></ul>
<pre>+------------+
|    /}      |
|&amp;#/$?   \   |
|  / \&amp;      |
|            |
|            |
|         0  |
|         !  |
|            |
|            |
|    {1  /#  |
| {          |
|\\@         |
+------------+
</pre>

<h2>Computational Class</h2>

<p>The last example in the previous section was written to demonstrate that Nhohnhehr is at least as powerful as a
push-down automaton.</p>

<p>The author suspects Nhohnhehr to be more powerful still; at least a linear bounded automaton,
but possibly even Turing-complete.  A strategy for simulating a Turing machine could be developed from the above examples:
create new rooms to represent new tape cells, with each possible orientation of the room representing a different tape symbol.
The finite control is encoded and embedded in the possible pathways that the instruction pointer can traverse inside each room.
Because rooms cannot be changed once created, one might have to resort to creative measures to "change" a tape cell; for
instance, each tape cell might have a "stack" of rooms, with a new room appended to the stack each time the cell is to be "changed".</p>

<h2>Source</h2>

<p>This document was adapted from
<a class="external" href="http://www.esolangs.org/wiki/Nhohnhehr">the esolangs.org wiki page for Nhohnhehr</a>,
which, like all esowiki articles, has been placed under public domain dedication.</p>

</body>
</html>
